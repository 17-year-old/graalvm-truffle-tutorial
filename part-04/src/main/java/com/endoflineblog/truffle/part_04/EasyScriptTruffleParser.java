package com.endoflineblog.truffle.part_04;

import com.endoflineblog.truffle.part_03.AdditionNode;
import com.endoflineblog.truffle.part_03.AdditionNodeGen;
import com.endoflineblog.truffle.part_03.DoubleLiteralNode;
import com.endoflineblog.truffle.part_03.EasyScriptNode;
import com.endoflineblog.truffle.part_03.IntLiteralNode;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.io.IOException;
import java.io.Reader;

/**
 * This the parser class that turns EasyScript code into the equivalent
 * {@link EasyScriptNode Truffle AST from part 3}.
 * It uses classes generated by the ANTLR Gradle plugin,
 * {@link EasyScriptLexer} and {@link EasyScriptParser},
 * from the grammar file specified in src/main/antlr/com/endoflineblog/truffle/part_04/EasyScript.g4.
 *
 * @see #parse(String)
 * @see #parse(Reader)
 */
public final class EasyScriptTruffleParser {
    public static EasyScriptNode parse(String program) {
        return parse(new ANTLRInputStream(program));
    }

    public static EasyScriptNode parse(Reader program) throws IOException {
        return parse(new ANTLRInputStream(program));
    }

    private static EasyScriptNode parse(CharStream inputStream) {
        var lexer = new EasyScriptLexer(inputStream);
        // remove the default console error listener
        lexer.removeErrorListeners();
        var parser = new EasyScriptParser(new CommonTokenStream(lexer));
        // remove the default console error listener
        parser.removeErrorListeners();
        // throw an exception when a parsing error is encountered
        parser.setErrorHandler(new BailErrorStrategy());
        EasyScriptParser.ExprContext context = parser.start().expr();
        return expr2TruffleNode(context);
    }

    private static EasyScriptNode expr2TruffleNode(EasyScriptParser.ExprContext expr) {
        return expr instanceof EasyScriptParser.AddExprContext
                ? addExpr2AdditionNode((EasyScriptParser.AddExprContext) expr)
                : literalExpr2ExprNode((EasyScriptParser.LiteralExprContext) expr);
    }

    private static AdditionNode addExpr2AdditionNode(EasyScriptParser.AddExprContext addExpr) {
        return AdditionNodeGen.create(
                expr2TruffleNode(addExpr.left),
                expr2TruffleNode(addExpr.right)
        );
    }

    private static EasyScriptNode literalExpr2ExprNode(EasyScriptParser.LiteralExprContext literalExpr) {
        TerminalNode intTerminal = literalExpr.literal().INT();
        return intTerminal != null
                ? parseIntLiteral(intTerminal.getText())
                : parseDoubleLiteral(literalExpr.getText());
    }

    private static EasyScriptNode parseIntLiteral(String text) {
        try {
            return new IntLiteralNode(Integer.parseInt(text));
        } catch (NumberFormatException e) {
            // it's possible that the integer literal is too big to fit in a 32-bit Java `int` -
            // in that case, fall back to a double literal
            return parseDoubleLiteral(text);
        }
    }

    private static DoubleLiteralNode parseDoubleLiteral(String text) {
        return new DoubleLiteralNode(Double.parseDouble(text));
    }
}
