# Part 5 - global variables

In this part of the series,
we add support for (global) variables to the language.

## Grammar

The grammar is in the [`EasyScript.g4` file](src/main/antlr/com/endoflineblog/truffle/part_05/EasyScript.g4).
We add statements to our language --
parsing our program will now result in a list of statements --
and also expression precedence,
so that `a = 1 + 1` is parsed as `a = (1 + 1)`,
and not `(a = 1) + 1`.

## `TruffleLanguage` class

Our [`TruffleLanguage` class](src/main/java/com/endoflineblog/truffle/part_05/EasyScriptTruffleLanguage.java)
implements the `parse(ParsingRequest)` method identically like in the
[previous part](../part-04/src/main/java/com/endoflineblog/truffle/part_04/EasyScriptTruffleLanguage.java) --
by delegating to the [parser](src/main/java/com/endoflineblog/truffle/part_05/EasyScriptTruffleParser.java),
which uses the classes generated by ANTLR from the aforementioned
[`EasyScript.g4` file](src/main/antlr/com/endoflineblog/truffle/part_05/EasyScript.g4)
to perform the parsing, and then translates the parse tree into the Truffle AST.
We handle a single declaration creating multiple new variables in code like
`let a, b;` by transforming it into the equivalent `let a; let b;`.
If a variable declaration does not have an initializer,
we create it with the `undefined` literal expression as the initializer,
basically transforming `let c;` into the equivalent `let c = undefined;`.

We also use a `LanguageContext` class in this version of our `TruffleLanguage`.
Our [`EasyScriptLanguageContext` class](src/main/java/com/endoflineblog/truffle/part_05/EasyScriptLanguageContext.java)
contains the `GlobalScopeObject` instance which stores the values of the global variables.
We return that object from the
[`TruffleLanguage.getScope()` method](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/TruffleLanguage.html#getScope-C-),
which allows retrieving the global variables using the
[`getBindings(String languageId)` method of the GraalVM polyglot `Context` class](https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html#getBindings-java.lang.String-).

## `GlobalScopeObject` class

The [`GlobalScopeObject` class](src/main/java/com/endoflineblog/truffle/part_05/runtime/GlobalScopeObject.java)
stores our global variables in a regular Java `Map`.
It also saves which variables are `const`,
as any attempt to update them should result in an error.
It has methods that can be used to create, update and retrieve variables,
which will be invoked from the new Truffle AST Nodes.

Since this object is returned from the
[`getBindings(String languageId)` method of the GraalVM polyglot `Context` class](https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html#getBindings-java.lang.String-),
it needs to be a GraalVM interop object.
This means implementing the
[`TruffleObject` interface](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/TruffleObject.html),
and also messages from
[Truffle's interoperability library](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html).
You implement this library by annotating your class with the
[`@ExportLibrary` annotation](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/library/ExportLibrary.html),
passing it the `InteropLibrary` class,
and then write instance methods for each message you want to implement --
in the case of `GlobalScopeObject`,
we implement messages that allow reading the values of the global variables.
Each message method needs to be annotated with the
[`@ExportMessage` annotation](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/library/ExportMessage.html),
and its name must either match the name of the message,
or you must use the `name` attribute of the `@ExportMessage`,
and pass the name of the message there.

Note that the first argument of the messages in
[Truffle's interoperability library](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html)
is the receiver,
which is assumed to be your class when implementing the messages,
so your instance methods should skip the first argument when implementing the messages.
Also note that the message methods do not have to be `public` --
it's common to make them package-private,
in order to not pollute the public API of the class with these interop-specific methods.

## `Undefined` class

Since we can now return an instance of the
[`Undefined` class](src/main/java/com/endoflineblog/truffle/part_05/runtime/Undefined.java),
which represents the JavaScript `undefined` vale,
when evaluating EasyScript code
(in programs like `let a; a`),
it also needs to be a GraalVM interop object,
same as `GlobalScopeObject`.
In this case, we only implement the
[`isNull()`](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html#isNull-java.lang.Object-)
and
[`toDisplayString(boolean)`](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html#toDisplayString-java.lang.Object-boolean-)
messages.

## Truffle AST Nodes

We separate the AST Nodes into two hierarchies:
[statements](src/main/java/com/endoflineblog/truffle/part_05/nodes/stmts/EasyScriptStmtNode.java),
and [expressions](src/main/java/com/endoflineblog/truffle/part_05/nodes/exprs/EasyScriptExprNode.java).

For statements, we add a Node representing the
[declaration of a new variable](src/main/java/com/endoflineblog/truffle/part_05/nodes/stmts/GlobalVarDeclStmtNode.java).
It uses the Truffle DSL that we learned about in
[part 3](../part-03/ReadMe.md).
The `@NodeField` annotations allow us to add fields to the subclass generated by the DSL
(which we can access in the superclass by declaring abstract getters for them),
and the `@CachedContext` annotation in the `@Specialization`
method allows access to the `EasyScriptLanguageContext`,
and in this way to the `GlobalScopeObject`,
where we create the new variable.
We also add an
[expression statement Node](src/main/java/com/endoflineblog/truffle/part_05/nodes/stmts/ExprStmtNode.java),
from which we simply return the value of the evaluated expression.

For expressions, we add the
[assignment expression Node](src/main/java/com/endoflineblog/truffle/part_05/nodes/exprs/GlobalVarAssignmentExprNode.java),
which looks almost identical to the declaration statement,
just updating the variable instead of creating it.
We also have a new
[reference expression Node](src/main/java/com/endoflineblog/truffle/part_05/nodes/exprs/GlobalVarReferenceExprNode.java),
which reads the value of a (global) variable from `GlobalScopeObject`,
and the
[`undefined` literal Node](src/main/java/com/endoflineblog/truffle/part_05/nodes/exprs/UndefinedLiteralExprNode.java),
which simply returns `Undefined.INSTANCE` from `executeGeneric()`,
and throws `UnexpectedResultException` from the remaining `execute*()` methods.
The presence of `undefined` also forces us to make a change to the
[`AdditionExprNode`](src/main/java/com/endoflineblog/truffle/part_05/nodes/exprs/AdditionExprNode.java),
to add a specialization handling it;
in accordance with JavaScript semantics,
we return `Double.NaN` if any side of addition is `undefined`.

Finally, we have the `RootNode`.
It takes in a list of statements,
and in its `execute()` method evaluates them all,
and returns the value of the last one.
The one interesting part of our
[`EasyScriptRootNode` class](src/main/java/com/endoflineblog/truffle/part_05/nodes/EasyScriptRootNode.java)
is that it implements
[JavaScript variable hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting),
by replacing each `var` declaration with a combination of new a variable initialized with `undefined`,
and then an assignment expression.
For that assignment expression, we have to make sure to return `undefined` as a result of evaluating it,
to be consistent with `let` and `const` declarations,
so we pass `false` as the second argument of the `ExprStmtNode` constructor,
which makes it ignore the value of the expression,
and always return `Undefined.INSTANCE`.

---

There is a [unit test](src/test/java/com/endoflineblog/truffle/part_05/GlobalVariablesTest.java)
exercising the positive test cases,
and the possible errors, like duplicate variable declarations,
or referencing an undeclared variable.
