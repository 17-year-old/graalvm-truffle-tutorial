# Part 6 - static function calls

In this part of the series,
we add support for function calls to our language.

We implement two built-in JavaScript functions from the
[`Math` object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math),
[`Math.abs()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs) and
[`Math.pow()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow).

## Grammar

The grammar is in the [`EasyScript.g4` file](src/main/antlr/com/endoflineblog/truffle/part_06/EasyScript.g4).
The only changes compared to the [grammar from part 5](../part-05/src/main/antlr/com/endoflineblog/truffle/part_05/EasyScript.g4)
are a few new expression types: we add call expressions, of course,
but also complex references, so we can write `Math.abs`.
We also introduce negation ("unary minus") expressions, like `-3`,
so that we can test the `Math.abs` function with negative numbers.

## `TruffleLanguage` class

Our [`TruffleLanguage` class](src/main/java/com/endoflineblog/truffle/part_06/EasyScriptTruffleLanguage.java)
implements the `parse(ParsingRequest)` method identically like in the
[previous part](../part-05/src/main/java/com/endoflineblog/truffle/part_05/EasyScriptTruffleLanguage.java) --
by delegating to the [parser](src/main/java/com/endoflineblog/truffle/part_06/EasyScriptTruffleParser.java),
which uses the classes generated by ANTLR from the aforementioned
[`EasyScript.g4` file](src/main/antlr/com/endoflineblog/truffle/part_06/EasyScript.g4)
to perform the parsing, and then translates the parse tree into the Truffle AST.
Note that we convert a complex reference like `Math.abs` into a simple name `"Math.abs"`.
Since we don't allow periods in the name of variables,
we know user-defined variables will never collide with these interpreter-created variables.

Inside the `createContext()` method,
we populate the global scope
(which is the same global scope we introduced in the [previous article](../part-05))
with the built-in functions.
Each function is represented by the `FunctionObject` class,
which contains a `CallTarget`
(something that we've been seeing since [part 1](../part-01)),
which contains a `RootNode`,
which contains the expression Node representing the body of the function.
This body Node has as its children as many
[`ReadFunctionArgExprNode` instances](src/main/java/com/endoflineblog/truffle/part_06/nodes/exprs/functions/ReadFunctionArgExprNode.java)
as arguments that function takes.
This allows writing `@Specialization`s in the expression body Node that simply use the values of the function arguments.

Note that, for the `pow()` function,
we make its body expression Node,
the [`PowFunctionBodyExprNode` class](src/main/java/com/endoflineblog/truffle/part_06/nodes/exprs/functions/built_in/PowFunctionBodyExprNode.java),
inherit from the [`BuiltInFunctionBodyExprNode` class](src/main/java/com/endoflineblog/truffle/part_06/nodes/exprs/functions/built_in/BuiltInFunctionBodyExprNode.java)
which uses Truffle's `@GenerateNodeFactory` annotation.
This makes the Truffle DSL generate a `PowFunctionBodyExprNodeFactory` class which implements the `NodeFactory<PowFunctionBodyExprNode>` interface.
That interface can then be used to write a helper method inside [`EasyScriptTruffleLanguage`](src/main/java/com/endoflineblog/truffle/part_06/EasyScriptTruffleLanguage.java)
(in our case, that method is called `defineBuiltInFunction()`)
that reduces duplication when creating an instance of the built-in function's body expression Node.

## The invoking side

The invoking side is implemented by the
[`FunctionCallExprNode` class](src/main/java/com/endoflineblog/truffle/part_06/nodes/exprs/functions/FunctionCallExprNode.java).
It evaluates the target of the call, its arguments,
and then delegates to a `FunctionDispatchNode`.

The [`FunctionDispatchNode` class](src/main/java/com/endoflineblog/truffle/part_06/nodes/exprs/functions/FunctionDispatchNode.java)
uses specializations to optimize the performance of function calls,
depending on how stable the target of the call is.

## `FunctionObject` as a polyglot value

Finally, we need to make our
[`FunctionObject` class](src/main/java/com/endoflineblog/truffle/part_06/runtime/FunctionObject.java)
a polyglot value, similarly like we did for `Undefined` in the
[previous article](../part-05/ReadMe.md#undefined-class),
as functions can now be returned from EasyScript code
(for example, in expressions like `Math.abs;`).
So, we make `FunctionObject` implement the `TruffleObject` marker interface,
and, to allow our functions to be called from other languages,
override the [`isExecutable()`](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html#isExecutable-java.lang.Object-)
and [`execute()` messages](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html#execute-java.lang.Object-java.lang.Object...-)
from the [interop library](https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/interop/InteropLibrary.html).
When implementing `execute()`,
we re-use the `FunctionDispatchNode` we saw in `FunctionCallExprNode` above,
so that polyglot calls are optimized the same as in-language calls.

However, note that we now need to check whether the values we're called with are actually valid EasyScript values,
as other languages have the ability to pass arbitrary types into our Nodes,
which only handle `int`, `double`, `Undefined` and `FunctionObject` types.
So, we perform a check inside `FunctionObject.execute()` to make sure the passed arguments are of one of the types we allow.

---

There is a [unit test](src/test/java/com/endoflineblog/truffle/part_06/StaticFunctionCallsTest.java)
exercising a few common scenarios with function calls.
